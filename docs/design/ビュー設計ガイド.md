# ロット管理システム ビュー設計ガイド

## 目次

1. [ビューとは](#1-ビューとは)
2. [ビューを使うメリット](#2-ビューを使うメリット)
3. [推奨ビュー一覧](#3-推奨ビュー一覧)
4. [ビューのDDL](#4-ビューのddl)
5. [マテリアライズドビュー](#5-マテリアライズドビュー)
6. [ビュー設計のベストプラクティス](#6-ビュー設計のベストプラクティス)

---

## 1. ビューとは

### 1.1 基本概念

**ビュー(VIEW)**は、SELECT文の結果を仮想的なテーブルとして定義したものです。

```sql
-- ビュー定義の例
CREATE VIEW v_example AS
SELECT column1, column2
FROM table1
WHERE condition;

-- ビューの使用
SELECT * FROM v_example;
```

### 1.2 通常ビューとマテリアライズドビュー

| 種類 | 特徴 | 用途 |
|-----|------|------|
| **通常ビュー** | 実データを持たず、毎回元テーブルにクエリを発行 | 複雑なJOINの簡略化、権限制御 |
| **マテリアライズドビュー** | 実データを保持し、定期的にリフレッシュ | 重い集計処理の高速化 |

---

## 2. ビューを使うメリット

### 2.1 複雑なクエリの簡略化

複数テーブルのJOINや複雑な条件を、シンプルな名前でアクセス可能にします。

**Before:**
```sql
-- 毎回このクエリを書く必要がある
SELECT 
    p.maker_part_code,
    p.product_name,
    w.warehouse_name,
    SUM(l.current_quantity) as total_qty
FROM lots l
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
WHERE l.status = 'active'
GROUP BY p.maker_part_code, p.product_name, w.warehouse_name;
```

**After (ビューを使用):**
```sql
-- ビュー定義を1回作成
CREATE VIEW v_active_inventory AS
SELECT 
    p.maker_part_code,
    p.product_name,
    w.warehouse_name,
    SUM(l.current_quantity) as total_qty
FROM lots l
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
WHERE l.status = 'active'
GROUP BY p.maker_part_code, p.product_name, w.warehouse_name;

-- シンプルに使える
SELECT * FROM v_active_inventory;
```

### 2.2 セキュリティとアクセス制御

特定のカラムだけを見せたい場合、ビューを使えば元テーブルへの直接アクセスを制限できます。

```sql
-- パスワードハッシュを除外したビュー
CREATE VIEW v_users_public AS
SELECT 
    user_id,
    username,
    email,
    display_name,
    is_active,
    created_at
FROM users;
-- password_hashは含めない

-- 一般ユーザーには v_users_public へのアクセスのみ許可
GRANT SELECT ON v_users_public TO role_viewer;
```

### 2.3 データの整合性

ビューを使うことで、データの見せ方を統一できます。

---

## 3. 推奨ビュー一覧

ロット管理システムで有用なビューをカテゴリ別に整理します。

### 3.1 在庫系ビュー

| ビュー名 | 説明 | 主な用途 |
|---------|------|---------|
| `v_inventory_summary` | 製品×倉庫の在庫サマリ | ダッシュボード表示 |
| `v_lot_details` | ロット詳細(製品名、倉庫名等を含む) | ロット検索画面 |
| `v_expiring_lots` | 消費期限が近いロット一覧 | アラート通知 |
| `v_available_inventory` | 引当可能在庫一覧 | 引当画面 |

### 3.2 引当・出荷系ビュー

| ビュー名 | 説明 | 主な用途 |
|---------|------|---------|
| `v_allocation_status` | 受注明細の引当状況 | 出荷管理画面 |
| `v_shipment_schedule` | 出荷予定一覧 | 出荷スケジュール |
| `v_forecast_allocations` | フォーキャストと引当推奨の結合 | 引当計画画面 |

### 3.3 履歴・監査系ビュー

| ビュー名 | 説明 | 主な用途 |
|---------|------|---------|
| `v_stock_movements` | 在庫変動履歴(詳細情報付き) | トレーサビリティ |
| `v_adjustment_summary` | 調整履歴サマリ | 棚卸レポート |
| `v_operation_audit` | 操作ログ(ユーザー名付き) | 監査証跡 |

### 3.4 統計・分析系ビュー

| ビュー名 | 説明 | 主な用途 |
|---------|------|---------|
| `v_inventory_aging` | 在庫滞留日数分析 | 在庫分析 |
| `v_supplier_performance` | 仕入先別入荷実績 | サプライヤー評価 |
| `v_warehouse_utilization` | 倉庫稼働率 | 倉庫最適化 |

---

## 4. ビューのDDL

### 4.1 在庫サマリビュー

```sql
CREATE OR REPLACE VIEW v_inventory_summary AS
SELECT 
    p.product_id,
    p.maker_part_code,
    p.product_name,
    p.base_unit,
    w.warehouse_id,
    w.warehouse_code,
    w.warehouse_name,
    w.warehouse_type,
    ii.total_quantity,
    ii.allocated_quantity,
    ii.available_quantity,
    ii.last_updated
FROM inventory_items ii
JOIN products p ON ii.product_id = p.product_id
JOIN warehouses w ON ii.warehouse_id = w.warehouse_id
WHERE ii.total_quantity > 0
ORDER BY p.maker_part_code, w.warehouse_name;

COMMENT ON VIEW v_inventory_summary IS '在庫サマリ(製品×倉庫)';
```

**使用例:**
```sql
-- 全在庫一覧
SELECT * FROM v_inventory_summary;

-- 特定製品の在庫状況
SELECT * FROM v_inventory_summary 
WHERE maker_part_code = 'ABC-12345';

-- 引当可能在庫のみ
SELECT * FROM v_inventory_summary 
WHERE available_quantity > 0;
```

### 4.2 ロット詳細ビュー

```sql
CREATE OR REPLACE VIEW v_lot_details AS
SELECT 
    l.lot_id,
    l.lot_number,
    p.product_id,
    p.maker_part_code,
    p.product_name,
    w.warehouse_id,
    w.warehouse_code,
    w.warehouse_name,
    s.supplier_id,
    s.supplier_code,
    s.supplier_name,
    l.received_date,
    l.expiry_date,
    l.current_quantity,
    l.allocated_quantity,
    (l.current_quantity - l.allocated_quantity) as available_quantity,
    l.unit,
    l.status,
    CASE 
        WHEN l.expiry_date IS NOT NULL 
        THEN l.expiry_date - CURRENT_DATE 
        ELSE NULL 
    END as days_to_expiry,
    l.created_at,
    l.updated_at
FROM lots l
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
LEFT JOIN suppliers s ON l.supplier_id = s.supplier_id
ORDER BY l.received_date DESC, l.lot_number;

COMMENT ON VIEW v_lot_details IS 'ロット詳細(製品名、倉庫名、仕入先名を含む)';
```

**使用例:**
```sql
-- 消費期限が近い順
SELECT * FROM v_lot_details 
WHERE days_to_expiry IS NOT NULL 
ORDER BY days_to_expiry;

-- 引当可能なロット
SELECT * FROM v_lot_details 
WHERE available_quantity > 0 
  AND status = 'active';
```

### 4.3 消費期限アラートビュー

```sql
CREATE OR REPLACE VIEW v_expiring_lots AS
SELECT 
    l.lot_id,
    l.lot_number,
    p.maker_part_code,
    p.product_name,
    w.warehouse_name,
    l.expiry_date,
    l.current_quantity,
    l.allocated_quantity,
    (l.current_quantity - l.allocated_quantity) as available_quantity,
    (l.expiry_date - CURRENT_DATE) as days_to_expiry,
    CASE 
        WHEN (l.expiry_date - CURRENT_DATE) <= 3 THEN 'critical'
        WHEN (l.expiry_date - CURRENT_DATE) <= 7 THEN 'warning'
        ELSE 'normal'
    END as alert_level
FROM lots l
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
WHERE l.status = 'active'
  AND l.expiry_date IS NOT NULL
  AND l.expiry_date <= CURRENT_DATE + INTERVAL '14 days'
ORDER BY l.expiry_date;

COMMENT ON VIEW v_expiring_lots IS '消費期限が近いロット一覧(14日以内)';
```

**使用例:**
```sql
-- 緊急対応が必要なロット(3日以内)
SELECT * FROM v_expiring_lots WHERE alert_level = 'critical';

-- 警告レベル(7日以内)
SELECT * FROM v_expiring_lots WHERE alert_level = 'warning';
```

### 4.4 引当状況ビュー

```sql
CREATE OR REPLACE VIEW v_allocation_status AS
SELECT 
    o.order_id,
    o.order_number,
    c.customer_code,
    c.customer_name,
    dp.delivery_place_name,
    ol.order_line_id,
    p.maker_part_code,
    p.product_name,
    ol.delivery_date,
    ol.order_quantity,
    COALESCE(SUM(a.allocated_quantity), 0) as allocated_quantity,
    ol.order_quantity - COALESCE(SUM(a.allocated_quantity), 0) as remaining_quantity,
    CASE 
        WHEN COALESCE(SUM(a.allocated_quantity), 0) = 0 THEN 'not_allocated'
        WHEN COALESCE(SUM(a.allocated_quantity), 0) < ol.order_quantity THEN 'partially_allocated'
        ELSE 'fully_allocated'
    END as allocation_status
FROM orders o
JOIN order_lines ol ON o.order_id = ol.order_id
JOIN customers c ON o.customer_id = c.customer_id
JOIN delivery_places dp ON o.delivery_place_id = dp.delivery_place_id
JOIN products p ON ol.product_id = p.product_id
LEFT JOIN allocations a ON ol.order_line_id = a.order_line_id 
                        AND a.status IN ('allocated', 'shipped')
WHERE o.status NOT IN ('completed', 'cancelled')
GROUP BY 
    o.order_id, o.order_number, c.customer_code, c.customer_name,
    dp.delivery_place_name, ol.order_line_id, p.maker_part_code,
    p.product_name, ol.delivery_date, ol.order_quantity
ORDER BY ol.delivery_date, o.order_number;

COMMENT ON VIEW v_allocation_status IS '受注明細の引当状況';
```

**使用例:**
```sql
-- 未引当の受注明細
SELECT * FROM v_allocation_status 
WHERE allocation_status = 'not_allocated';

-- 部分引当の明細
SELECT * FROM v_allocation_status 
WHERE allocation_status = 'partially_allocated';
```

### 4.5 在庫変動履歴ビュー

```sql
CREATE OR REPLACE VIEW v_stock_movements AS
SELECT 
    sh.history_id,
    sh.transaction_date,
    sh.transaction_type,
    l.lot_number,
    p.maker_part_code,
    p.product_name,
    w.warehouse_name,
    sh.quantity_change,
    sh.quantity_after,
    sh.reference_type,
    sh.reference_id
FROM stock_history sh
JOIN lots l ON sh.lot_id = l.lot_id
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
ORDER BY sh.transaction_date DESC;

COMMENT ON VIEW v_stock_movements IS '在庫変動履歴(製品名・倉庫名付き)';
```

**使用例:**
```sql
-- 特定ロットの履歴
SELECT * FROM v_stock_movements 
WHERE lot_number = 'LOT-20250115-001';

-- 過去7日間の入荷履歴
SELECT * FROM v_stock_movements 
WHERE transaction_type = 'inbound'
  AND transaction_date >= CURRENT_DATE - INTERVAL '7 days';
```

### 4.6 調整サマリビュー

```sql
CREATE OR REPLACE VIEW v_adjustment_summary AS
SELECT 
    a.adjustment_id,
    a.adjusted_at,
    a.adjustment_type,
    l.lot_number,
    p.maker_part_code,
    p.product_name,
    w.warehouse_name,
    a.adjusted_quantity,
    a.reason,
    u.display_name as adjusted_by_name
FROM adjustments a
JOIN lots l ON a.lot_id = l.lot_id
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
JOIN users u ON a.adjusted_by = u.user_id
ORDER BY a.adjusted_at DESC;

COMMENT ON VIEW v_adjustment_summary IS '在庫調整履歴サマリ';
```

### 4.7 操作ログビュー

```sql
CREATE OR REPLACE VIEW v_operation_audit AS
SELECT 
    ol.log_id,
    ol.created_at,
    u.username,
    u.display_name,
    ol.operation_type,
    ol.target_table,
    ol.target_id,
    ol.changes,
    ol.ip_address
FROM operation_logs ol
LEFT JOIN users u ON ol.user_id = u.user_id
ORDER BY ol.created_at DESC;

COMMENT ON VIEW v_operation_audit IS '操作ログ(ユーザー情報付き)';
```

---

## 5. マテリアライズドビュー

### 5.1 マテリアライズドビューとは

**通常ビュー**は実データを持ちませんが、**マテリアライズドビュー**は実データを保持します。

**メリット:**
- 重い集計処理を事前計算できる
- クエリパフォーマンスが大幅に向上

**デメリット:**
- データが最新でない可能性がある(定期リフレッシュが必要)
- ストレージを消費する

### 5.2 マテリアライズドビューの作成

```sql
-- 在庫滞留日数分析(重い集計)
CREATE MATERIALIZED VIEW mv_inventory_aging AS
SELECT 
    p.product_id,
    p.maker_part_code,
    p.product_name,
    w.warehouse_id,
    w.warehouse_name,
    l.lot_number,
    l.received_date,
    CURRENT_DATE - l.received_date as days_in_stock,
    l.current_quantity,
    CASE 
        WHEN CURRENT_DATE - l.received_date <= 30 THEN '0-30 days'
        WHEN CURRENT_DATE - l.received_date <= 60 THEN '31-60 days'
        WHEN CURRENT_DATE - l.received_date <= 90 THEN '61-90 days'
        ELSE '90+ days'
    END as aging_category
FROM lots l
JOIN products p ON l.product_id = p.product_id
JOIN warehouses w ON l.warehouse_id = w.warehouse_id
WHERE l.status = 'active'
  AND l.current_quantity > 0;

-- インデックスを追加して検索を高速化
CREATE INDEX idx_mv_inventory_aging_product ON mv_inventory_aging(product_id);
CREATE INDEX idx_mv_inventory_aging_category ON mv_inventory_aging(aging_category);

COMMENT ON MATERIALIZED VIEW mv_inventory_aging IS '在庫滞留日数分析(マテリアライズド)';
```

### 5.3 リフレッシュ方法

```sql
-- 完全リフレッシュ(全データを再計算)
REFRESH MATERIALIZED VIEW mv_inventory_aging;

-- 同時実行リフレッシュ(読取をブロックしない)
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_inventory_aging;
```

**リフレッシュのタイミング:**
- 日次バッチで自動実行
- 特定のイベント後(棚卸完了後等)
- 手動実行(必要に応じて)

### 5.4 推奨マテリアライズドビュー

| ビュー名 | 説明 | リフレッシュ頻度 |
|---------|------|----------------|
| `mv_inventory_aging` | 在庫滞留日数分析 | 日次(深夜) |
| `mv_supplier_performance` | 仕入先別入荷実績 | 週次 |
| `mv_warehouse_utilization` | 倉庫稼働率 | 日次 |
| `mv_monthly_shipment_summary` | 月次出荷サマリ | 月次 |

---

## 6. ビュー設計のベストプラクティス

### 6.1 命名規則

| プレフィックス | 意味 | 例 |
|--------------|------|---|
| `v_` | 通常ビュー | `v_inventory_summary` |
| `mv_` | マテリアライズドビュー | `mv_inventory_aging` |

### 6.2 パフォーマンス考慮事項

**✅ DO (推奨):**
- 必要なカラムだけを含める(SELECT *)を避ける
- WHERE句でフィルタリングできるものはビュー内で実施
- 頻繁に使う複雑な集計はマテリアライズドビューに

**❌ DON'T (非推奨):**
- ビューの上にビューを何層も重ねる
- 過度に複雑なJOINや副問い合わせ
- WHERE句なしの全件取得ビュー(大量データの場合)

### 6.3 セキュリティ考慮事項

```sql
-- センシティブ情報を除外したビュー
CREATE VIEW v_users_safe AS
SELECT 
    user_id,
    username,
    display_name,
    is_active
FROM users;
-- password_hash, email は含めない

-- 権限付与
GRANT SELECT ON v_users_safe TO role_viewer;
REVOKE ALL ON users FROM role_viewer;
```

### 6.4 メンテナンス性

**ビューにはコメントを付ける:**
```sql
COMMENT ON VIEW v_inventory_summary IS 
'在庫サマリ: 製品×倉庫の在庫状況。
 total_quantity: 合計在庫数
 allocated_quantity: 引当済数量
 available_quantity: 引当可能数量';
```

**依存関係を管理する:**
- テーブル構造変更時、影響を受けるビューを把握
- `OR REPLACE`を使ってビュー再作成を簡単に

---

## 7. 実装手順

### 7.1 ビュー作成の流れ

1. **要件定義**: どの画面・レポートで使うか明確化
2. **クエリ作成**: 通常のSELECT文で動作確認
3. **ビュー化**: CREATE VIEW文に変換
4. **テスト**: パフォーマンスと結果を確認
5. **権限設定**: 必要なロールに権限付与
6. **ドキュメント化**: コメント追加と使用方法記載

### 7.2 パフォーマンステスト

```sql
-- クエリ実行計画を確認
EXPLAIN ANALYZE SELECT * FROM v_inventory_summary;

-- 実行時間を計測
\timing on
SELECT * FROM v_lot_details WHERE maker_part_code = 'ABC-12345';
```

---

## 8. まとめ

### ビューの使い分け

| 用途 | 推奨 | 理由 |
|-----|------|------|
| 複雑なJOINの簡略化 | 通常ビュー | 常に最新データが必要 |
| 重い集計処理 | マテリアライズドビュー | パフォーマンス優先 |
| セキュリティ制御 | 通常ビュー | リアルタイム性が重要 |
| 統計レポート | マテリアライズドビュー | 若干古いデータでもOK |

### 次のステップ

1. **v2.2で実装するビュー**を選定
2. DDLファイルに追加
3. API側でビューを活用したエンドポイント作成
4. フロントエンド画面で表示

---

**Document Version:** 1.0  
**Created:** 2025-11-15  
**Author:** 和也 + AI
